/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/ts-exif-parser/index.js":
/*!**********************************************!*\
  !*** ./node_modules/ts-exif-parser/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ThumbnailTypes = exports.ExifData = exports.OrientationTypes = exports.ExifParserFactory = void 0;\r\nvar ExifParserFactory_1 = __webpack_require__(/*! ./lib/ExifParserFactory */ \"./node_modules/ts-exif-parser/lib/ExifParserFactory.js\");\r\nObject.defineProperty(exports, \"ExifParserFactory\", ({ enumerable: true, get: function () { return ExifParserFactory_1.ExifParserFactory; } }));\r\nvar ExifData_1 = __webpack_require__(/*! ./lib/ExifData */ \"./node_modules/ts-exif-parser/lib/ExifData.js\");\r\nObject.defineProperty(exports, \"OrientationTypes\", ({ enumerable: true, get: function () { return ExifData_1.OrientationTypes; } }));\r\nObject.defineProperty(exports, \"ExifData\", ({ enumerable: true, get: function () { return ExifData_1.ExifData; } }));\r\nObject.defineProperty(exports, \"ThumbnailTypes\", ({ enumerable: true, get: function () { return ExifData_1.ThumbnailTypes; } }));\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ian_webpack/./node_modules/ts-exif-parser/index.js?");

/***/ }),

/***/ "./node_modules/ts-exif-parser/lib/BufferStream.js":
/*!*********************************************************!*\
  !*** ./node_modules/ts-exif-parser/lib/BufferStream.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BufferStream = void 0;\r\nvar BufferStream = /** @class */ (function () {\r\n    function BufferStream(buffer, offset, length, bigEndian) {\r\n        if (offset === void 0) { offset = 0; }\r\n        if (length === void 0) { length = buffer.length; }\r\n        this.buffer = buffer;\r\n        this.offset = offset;\r\n        this.length = length;\r\n        this.bigEndian = bigEndian;\r\n        this.endPosition = this.offset + length;\r\n        this.setBigEndian(bigEndian);\r\n    }\r\n    BufferStream.prototype.setBigEndian = function (bigEndian) {\r\n        this.bigEndian = !!bigEndian;\r\n    };\r\n    BufferStream.prototype.nextUInt8 = function () {\r\n        var value = this.buffer.readUInt8(this.offset);\r\n        this.offset += 1;\r\n        return value;\r\n    };\r\n    BufferStream.prototype.nextInt8 = function () {\r\n        var value = this.buffer.readInt8(this.offset);\r\n        this.offset += 1;\r\n        return value;\r\n    };\r\n    BufferStream.prototype.nextUInt16 = function () {\r\n        var value = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);\r\n        this.offset += 2;\r\n        return value;\r\n    };\r\n    BufferStream.prototype.nextUInt32 = function () {\r\n        var value = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);\r\n        this.offset += 4;\r\n        return value;\r\n    };\r\n    BufferStream.prototype.nextInt16 = function () {\r\n        var value = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);\r\n        this.offset += 2;\r\n        return value;\r\n    };\r\n    BufferStream.prototype.nextInt32 = function () {\r\n        var value = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);\r\n        this.offset += 4;\r\n        return value;\r\n    };\r\n    BufferStream.prototype.nextFloat = function () {\r\n        var value = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);\r\n        this.offset += 4;\r\n        return value;\r\n    };\r\n    BufferStream.prototype.nextDouble = function () {\r\n        var value = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);\r\n        this.offset += 8;\r\n        return value;\r\n    };\r\n    BufferStream.prototype.nextBuffer = function (length) {\r\n        var value = this.buffer.slice(this.offset, this.offset + length);\r\n        this.offset += length;\r\n        return value;\r\n    };\r\n    BufferStream.prototype.remainingLength = function () {\r\n        return this.endPosition - this.offset;\r\n    };\r\n    BufferStream.prototype.nextString = function (length) {\r\n        var value = this.buffer.toString('utf8', this.offset, this.offset + length);\r\n        this.offset += length;\r\n        return value;\r\n    };\r\n    BufferStream.prototype.mark = function () {\r\n        var self = this;\r\n        return {\r\n            openWithOffset: function (offset) {\r\n                offset = (offset || 0) + this.offset;\r\n                return new BufferStream(self.buffer, offset, self.endPosition - offset, self.bigEndian);\r\n            },\r\n            offset: this.offset\r\n        };\r\n    };\r\n    BufferStream.prototype.offsetFrom = function (marker) {\r\n        return this.offset - marker.offset;\r\n    };\r\n    BufferStream.prototype.skip = function (amount) {\r\n        this.offset += amount;\r\n    };\r\n    BufferStream.prototype.branch = function (offset, length) {\r\n        length = typeof length === 'number' ? length : this.endPosition - (this.offset + offset);\r\n        return new BufferStream(this.buffer, this.offset + offset, length, this.bigEndian);\r\n    };\r\n    return BufferStream;\r\n}());\r\nexports.BufferStream = BufferStream;\r\n//# sourceMappingURL=BufferStream.js.map\n\n//# sourceURL=webpack://ian_webpack/./node_modules/ts-exif-parser/lib/BufferStream.js?");

/***/ }),

/***/ "./node_modules/ts-exif-parser/lib/DOMBufferStream.js":
/*!************************************************************!*\
  !*** ./node_modules/ts-exif-parser/lib/DOMBufferStream.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, lets: true, white: true */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DOMBufferStream = void 0;\r\nvar DOMBufferStream = /** @class */ (function () {\r\n    function DOMBufferStream(arrayBuffer, offset, length, bigEndian, global, parentOffset) {\r\n        this.arrayBuffer = arrayBuffer;\r\n        this.offset = offset;\r\n        this.length = length;\r\n        this.bigEndian = bigEndian;\r\n        this.global = global;\r\n        this.parentOffset = parentOffset;\r\n        this.global = global;\r\n        offset = offset || 0;\r\n        length = length || (arrayBuffer.byteLength - offset);\r\n        this.arrayBuffer = arrayBuffer.slice(offset, offset + length);\r\n        this.view = new global.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength);\r\n        this.setBigEndian(bigEndian);\r\n        this.offset = 0;\r\n        this.parentOffset = (parentOffset || 0) + offset;\r\n    }\r\n    DOMBufferStream.prototype.setBigEndian = function (bigEndian) {\r\n        this.littleEndian = !bigEndian;\r\n    };\r\n    DOMBufferStream.prototype.nextUInt8 = function () {\r\n        var value = this.view.getUint8(this.offset);\r\n        this.offset += 1;\r\n        return value;\r\n    };\r\n    DOMBufferStream.prototype.nextInt8 = function () {\r\n        var value = this.view.getInt8(this.offset);\r\n        this.offset += 1;\r\n        return value;\r\n    };\r\n    DOMBufferStream.prototype.nextUInt16 = function () {\r\n        var value = this.view.getUint16(this.offset, this.littleEndian);\r\n        this.offset += 2;\r\n        return value;\r\n    };\r\n    DOMBufferStream.prototype.nextUInt32 = function () {\r\n        var value = this.view.getUint32(this.offset, this.littleEndian);\r\n        this.offset += 4;\r\n        return value;\r\n    };\r\n    DOMBufferStream.prototype.nextInt16 = function () {\r\n        var value = this.view.getInt16(this.offset, this.littleEndian);\r\n        this.offset += 2;\r\n        return value;\r\n    };\r\n    DOMBufferStream.prototype.nextInt32 = function () {\r\n        var value = this.view.getInt32(this.offset, this.littleEndian);\r\n        this.offset += 4;\r\n        return value;\r\n    };\r\n    DOMBufferStream.prototype.nextFloat = function () {\r\n        var value = this.view.getFloat32(this.offset, this.littleEndian);\r\n        this.offset += 4;\r\n        return value;\r\n    };\r\n    DOMBufferStream.prototype.nextDouble = function () {\r\n        var value = this.view.getFloat64(this.offset, this.littleEndian);\r\n        this.offset += 8;\r\n        return value;\r\n    };\r\n    DOMBufferStream.prototype.nextBuffer = function (length) {\r\n        //this won't work in IE10\r\n        var value = this.arrayBuffer.slice(this.offset, this.offset + length);\r\n        this.offset += length;\r\n        return value;\r\n    };\r\n    DOMBufferStream.prototype.remainingLength = function () {\r\n        return this.arrayBuffer.byteLength - this.offset;\r\n    };\r\n    DOMBufferStream.prototype.nextString = function (length) {\r\n        var value = this.arrayBuffer.slice(this.offset, this.offset + length);\r\n        value = String.fromCharCode.apply(null, new this.global.Uint8Array(value));\r\n        this.offset += length;\r\n        return value;\r\n    };\r\n    DOMBufferStream.prototype.mark = function () {\r\n        var self = this;\r\n        return {\r\n            openWithOffset: function (offset) {\r\n                offset = (offset || 0) + this.offset;\r\n                return new DOMBufferStream(self.arrayBuffer, offset, self.arrayBuffer.byteLength - offset, !self.littleEndian, self.global, self.parentOffset);\r\n            },\r\n            offset: this.offset,\r\n            getParentOffset: function () {\r\n                return self.parentOffset;\r\n            }\r\n        };\r\n    };\r\n    DOMBufferStream.prototype.offsetFrom = function (marker) {\r\n        return this.parentOffset + this.offset - (marker.offset + marker.getParentOffset());\r\n    };\r\n    DOMBufferStream.prototype.skip = function (amount) {\r\n        this.offset += amount;\r\n    };\r\n    DOMBufferStream.prototype.branch = function (offset, length) {\r\n        length = typeof length === 'number' ? length : this.arrayBuffer.byteLength - (this.offset + offset);\r\n        return new DOMBufferStream(this.arrayBuffer, this.offset + offset, length, !this.littleEndian, this.global, this.parentOffset);\r\n    };\r\n    return DOMBufferStream;\r\n}());\r\nexports.DOMBufferStream = DOMBufferStream;\r\n//# sourceMappingURL=DOMBufferStream.js.map\n\n//# sourceURL=webpack://ian_webpack/./node_modules/ts-exif-parser/lib/DOMBufferStream.js?");

/***/ }),

/***/ "./node_modules/ts-exif-parser/lib/DateUtil.js":
/*!*****************************************************!*\
  !*** ./node_modules/ts-exif-parser/lib/DateUtil.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DateUtil = void 0;\r\nvar DateUtil = /** @class */ (function () {\r\n    function DateUtil() {\r\n    }\r\n    DateUtil.parseNumber = function (s) {\r\n        return parseInt(s, 10);\r\n    };\r\n    /**\r\n     * take date (year, month, day) and time (hour, minutes, seconds) digits in UTC\r\n     * and return a timestamp in seconds\r\n     * @param dateParts\r\n     * @param timeParts\r\n     * @returns {number}\r\n     */\r\n    DateUtil.parseDateTimeParts = function (dateParts, timeParts) {\r\n        dateParts = dateParts.map(DateUtil.parseNumber);\r\n        timeParts = timeParts.map(DateUtil.parseNumber);\r\n        var year = dateParts[0];\r\n        var month = dateParts[1] - 1;\r\n        var day = dateParts[2];\r\n        var hours = timeParts[0];\r\n        var minutes = timeParts[1];\r\n        var seconds = timeParts[2];\r\n        var date = Date.UTC(year, month, day, hours, minutes, seconds, 0);\r\n        var timestamp = date / 1000;\r\n        return timestamp;\r\n    };\r\n    /**\r\n     * parse date with \"2004-09-04T23:39:06-08:00\" format,\r\n     * one of the formats supported by ISO 8601, and\r\n     * convert to utc timestamp in seconds\r\n     * @param dateTimeStr\r\n     * @returns {number}\r\n     */\r\n    DateUtil.parseDateWithTimezoneFormat = function (dateTimeStr) {\r\n        var dateParts = dateTimeStr.substr(0, 10).split('-');\r\n        var timeParts = dateTimeStr.substr(11, 8).split(':');\r\n        var timezoneStr = dateTimeStr.substr(19, 6);\r\n        var timezoneParts = timezoneStr.split(':').map(DateUtil.parseNumber);\r\n        var timezoneOffset = (timezoneParts[0] * DateUtil.hours) +\r\n            (timezoneParts[1] * DateUtil.minutes);\r\n        var timestamp = DateUtil.parseDateTimeParts(dateParts, timeParts);\r\n        //minus because the timezoneOffset describes\r\n        //how much the described time is ahead of UTC\r\n        timestamp -= timezoneOffset;\r\n        if (typeof timestamp === 'number' && !isNaN(timestamp)) {\r\n            return timestamp;\r\n        }\r\n    };\r\n    /**\r\n     * parse date with \"YYYY:MM:DD hh:mm:ss\" format, convert to utc timestamp in seconds\r\n     * @param dateTimeStr\r\n     * @returns {number}\r\n     */\r\n    DateUtil.parseDateWithSpecFormat = function (dateTimeStr) {\r\n        var parts = dateTimeStr.split(' '), dateParts = parts[0].split(':'), timeParts = parts[1].split(':');\r\n        var timestamp = DateUtil.parseDateTimeParts(dateParts, timeParts);\r\n        if (typeof timestamp === 'number' && !isNaN(timestamp)) {\r\n            return timestamp;\r\n        }\r\n    };\r\n    DateUtil.parseExifDate = function (dateTimeStr) {\r\n        //some easy checks to determine two common date formats\r\n        //is the date in the standard \"YYYY:MM:DD hh:mm:ss\" format?\r\n        var isSpecFormat = dateTimeStr.length === 19 &&\r\n            dateTimeStr.charAt(4) === ':';\r\n        //is the date in the non-standard format,\r\n        //\"2004-09-04T23:39:06-08:00\" to include a timezone?\r\n        var isTimezoneFormat = dateTimeStr.length === 25 &&\r\n            dateTimeStr.charAt(10) === 'T';\r\n        var timestamp;\r\n        if (isTimezoneFormat) {\r\n            return DateUtil.parseDateWithTimezoneFormat(dateTimeStr);\r\n        }\r\n        else if (isSpecFormat) {\r\n            return DateUtil.parseDateWithSpecFormat(dateTimeStr);\r\n        }\r\n    };\r\n    //in seconds\r\n    DateUtil.hours = 3600;\r\n    DateUtil.minutes = 60;\r\n    return DateUtil;\r\n}());\r\nexports.DateUtil = DateUtil;\r\n//# sourceMappingURL=DateUtil.js.map\n\n//# sourceURL=webpack://ian_webpack/./node_modules/ts-exif-parser/lib/DateUtil.js?");

/***/ }),

/***/ "./node_modules/ts-exif-parser/lib/ExifData.js":
/*!*****************************************************!*\
  !*** ./node_modules/ts-exif-parser/lib/ExifData.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ExifData = exports.ThumbnailTypes = exports.OrientationTypes = void 0;\r\nvar JpegParser_1 = __webpack_require__(/*! ./JpegParser */ \"./node_modules/ts-exif-parser/lib/JpegParser.js\");\r\nvar OrientationTypes;\r\n(function (OrientationTypes) {\r\n    OrientationTypes[OrientationTypes[\"TOP_LEFT\"] = 1] = \"TOP_LEFT\";\r\n    OrientationTypes[OrientationTypes[\"TOP_RIGHT\"] = 2] = \"TOP_RIGHT\";\r\n    OrientationTypes[OrientationTypes[\"BOTTOM_RIGHT\"] = 3] = \"BOTTOM_RIGHT\";\r\n    OrientationTypes[OrientationTypes[\"BOTTOM_LEFT\"] = 4] = \"BOTTOM_LEFT\";\r\n    OrientationTypes[OrientationTypes[\"LEFT_TOP\"] = 5] = \"LEFT_TOP\";\r\n    OrientationTypes[OrientationTypes[\"RIGHT_TOP\"] = 6] = \"RIGHT_TOP\";\r\n    OrientationTypes[OrientationTypes[\"RIGHT_BOTTOM\"] = 7] = \"RIGHT_BOTTOM\";\r\n    OrientationTypes[OrientationTypes[\"LEFT_BOTTOM\"] = 8] = \"LEFT_BOTTOM\";\r\n})(OrientationTypes = exports.OrientationTypes || (exports.OrientationTypes = {}));\r\nvar ThumbnailTypes;\r\n(function (ThumbnailTypes) {\r\n    ThumbnailTypes[ThumbnailTypes[\"jpeg\"] = 6] = \"jpeg\";\r\n    ThumbnailTypes[ThumbnailTypes[\"tiff\"] = 1] = \"tiff\";\r\n})(ThumbnailTypes = exports.ThumbnailTypes || (exports.ThumbnailTypes = {}));\r\nvar ExifData = /** @class */ (function () {\r\n    function ExifData(startMarker, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset) {\r\n        this.startMarker = startMarker;\r\n        this.tags = tags;\r\n        this.imageSize = imageSize;\r\n        this.thumbnailOffset = thumbnailOffset;\r\n        this.thumbnailLength = thumbnailLength;\r\n        this.thumbnailType = thumbnailType;\r\n        this.app1Offset = app1Offset;\r\n    }\r\n    ExifData.prototype.hasThumbnail = function (mime) {\r\n        if (!this.thumbnailOffset || !this.thumbnailLength) {\r\n            return false;\r\n        }\r\n        if (typeof mime !== 'string') {\r\n            return true;\r\n        }\r\n        if (mime.toLowerCase().trim() === 'image/jpeg') {\r\n            return this.thumbnailType === ThumbnailTypes.jpeg;\r\n        }\r\n        if (mime.toLowerCase().trim() === 'image/tiff') {\r\n            return this.thumbnailType === ThumbnailTypes.tiff;\r\n        }\r\n        return false;\r\n    };\r\n    ExifData.prototype.getThumbnailOffset = function () {\r\n        return this.app1Offset + 6 + this.thumbnailOffset;\r\n    };\r\n    ExifData.prototype.getThumbnailLength = function () {\r\n        return this.thumbnailLength;\r\n    };\r\n    ExifData.prototype.getThumbnailBuffer = function () {\r\n        return this.getThumbnailStream().nextBuffer(this.thumbnailLength);\r\n    };\r\n    ExifData.prototype.getThumbnailStream = function () {\r\n        return this.startMarker.openWithOffset(this.getThumbnailOffset());\r\n    };\r\n    ExifData.prototype.getImageSize = function () {\r\n        return this.imageSize;\r\n    };\r\n    ExifData.prototype.getThumbnailSize = function () {\r\n        var stream = this.getThumbnailStream(), size;\r\n        JpegParser_1.JpegParser.parseSections(stream, function (sectionType, sectionStream) {\r\n            if (JpegParser_1.JpegParser.getSectionName(sectionType).name === 'SOF') {\r\n                size = JpegParser_1.JpegParser.getSizeFromSOFSection(sectionStream);\r\n            }\r\n        });\r\n        return size;\r\n    };\r\n    return ExifData;\r\n}());\r\nexports.ExifData = ExifData;\r\n//# sourceMappingURL=ExifData.js.map\n\n//# sourceURL=webpack://ian_webpack/./node_modules/ts-exif-parser/lib/ExifData.js?");

/***/ }),

/***/ "./node_modules/ts-exif-parser/lib/ExifParser.js":
/*!*******************************************************!*\
  !*** ./node_modules/ts-exif-parser/lib/ExifParser.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ExifParser = void 0;\r\n/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, lets: true, white: true */\r\nvar simplify_1 = __webpack_require__(/*! ./simplify */ \"./node_modules/ts-exif-parser/lib/simplify.js\");\r\nvar JpegParser_1 = __webpack_require__(/*! ./JpegParser */ \"./node_modules/ts-exif-parser/lib/JpegParser.js\");\r\nvar ExifSectionParser_1 = __webpack_require__(/*! ./ExifSectionParser */ \"./node_modules/ts-exif-parser/lib/ExifSectionParser.js\");\r\nvar exif_tags_1 = __webpack_require__(/*! ./exif-tags */ \"./node_modules/ts-exif-parser/lib/exif-tags.js\");\r\nvar ExifData_1 = __webpack_require__(/*! ./ExifData */ \"./node_modules/ts-exif-parser/lib/ExifData.js\");\r\nvar ExifParser = /** @class */ (function () {\r\n    function ExifParser(stream) {\r\n        this.stream = stream;\r\n        this.flags = {\r\n            readBinaryTags: false,\r\n            resolveTagNames: true,\r\n            simplifyValues: true,\r\n            imageSize: true,\r\n            hidePointers: true,\r\n            returnTags: true\r\n        };\r\n    }\r\n    ExifParser.prototype.enableBinaryFields = function (enable) {\r\n        this.flags.readBinaryTags = enable;\r\n        return this;\r\n    };\r\n    ExifParser.prototype.enablePointers = function (enable) {\r\n        this.flags.hidePointers = !enable;\r\n        return this;\r\n    };\r\n    ExifParser.prototype.enableTagNames = function (enable) {\r\n        this.flags.resolveTagNames = enable;\r\n        return this;\r\n    };\r\n    ExifParser.prototype.enableImageSize = function (enable) {\r\n        this.flags.imageSize = enable;\r\n        return this;\r\n    };\r\n    ExifParser.prototype.enableReturnTags = function (enable) {\r\n        this.flags.returnTags = enable;\r\n        return this;\r\n    };\r\n    ExifParser.prototype.enableSimpleValues = function (enable) {\r\n        this.flags.simplifyValues = enable;\r\n        return this;\r\n    };\r\n    ExifParser.prototype.parse = function () {\r\n        var start = this.stream.mark(), stream = start.openWithOffset(0), flags = this.flags, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset, getTagValue, setTagValue;\r\n        if (flags.resolveTagNames) {\r\n            tags = {};\r\n            getTagValue = function (t) {\r\n                return tags[t.name];\r\n            };\r\n            setTagValue = function (t, value) {\r\n                tags[t.name] = value;\r\n            };\r\n        }\r\n        else {\r\n            tags = [];\r\n            getTagValue = function (t) {\r\n                var i;\r\n                for (i = 0; i < tags.length; ++i) {\r\n                    if (tags[i].type === t.type && tags[i].section === t.section) {\r\n                        return tags.value;\r\n                    }\r\n                }\r\n            };\r\n            setTagValue = function (t, value) {\r\n                var i;\r\n                for (i = 0; i < tags.length; ++i) {\r\n                    if (tags[i].type === t.type && tags[i].section === t.section) {\r\n                        tags.value = value;\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        JpegParser_1.JpegParser.parseSections(stream, function (sectionType, sectionStream) {\r\n            var validExifHeaders, sectionOffset = sectionStream.offsetFrom(start);\r\n            if (sectionType === 0xE1) {\r\n                validExifHeaders = ExifSectionParser_1.ExifSectionParser.parseTags(sectionStream, function (ifdSection, tagType, value, format) {\r\n                    //ignore binary fields if disabled\r\n                    if (!flags.readBinaryTags && format === 7) {\r\n                        return;\r\n                    }\r\n                    if (tagType === 0x0201) {\r\n                        thumbnailOffset = value[0];\r\n                        if (flags.hidePointers) {\r\n                            return;\r\n                        }\r\n                    }\r\n                    else if (tagType === 0x0202) {\r\n                        thumbnailLength = value[0];\r\n                        if (flags.hidePointers) {\r\n                            return;\r\n                        }\r\n                    }\r\n                    else if (tagType === 0x0103) {\r\n                        thumbnailType = value[0];\r\n                        if (flags.hidePointers) {\r\n                            return;\r\n                        }\r\n                    }\r\n                    //if flag is set to not store tags, return here after storing pointers\r\n                    if (!flags.returnTags) {\r\n                        return;\r\n                    }\r\n                    if (flags.simplifyValues) {\r\n                        value = simplify_1.simplify.simplifyValue(value, format);\r\n                    }\r\n                    if (flags.resolveTagNames) {\r\n                        var sectionTagNames = ifdSection === ExifSectionParser_1.ExifSections.GPSIFD ? exif_tags_1.Tags.GPS : exif_tags_1.Tags.Exif;\r\n                        var name_1 = sectionTagNames[tagType];\r\n                        if (!name_1) {\r\n                            name_1 = exif_tags_1.Tags.Exif[tagType];\r\n                        }\r\n                        if (!tags.hasOwnProperty(name_1)) {\r\n                            tags[name_1] = value;\r\n                        }\r\n                    }\r\n                    else {\r\n                        tags.push({\r\n                            section: ifdSection,\r\n                            type: tagType,\r\n                            value: value\r\n                        });\r\n                    }\r\n                });\r\n                if (validExifHeaders) {\r\n                    app1Offset = sectionOffset;\r\n                }\r\n            }\r\n            else if (flags.imageSize && JpegParser_1.JpegParser.getSectionName(sectionType).name === 'SOF') {\r\n                imageSize = JpegParser_1.JpegParser.getSizeFromSOFSection(sectionStream);\r\n            }\r\n        });\r\n        if (flags.simplifyValues) {\r\n            simplify_1.simplify.castDegreeValues(getTagValue, setTagValue);\r\n            simplify_1.simplify.castDateValues(getTagValue, setTagValue);\r\n        }\r\n        return new ExifData_1.ExifData(start, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset);\r\n    };\r\n    return ExifParser;\r\n}());\r\nexports.ExifParser = ExifParser;\r\n//# sourceMappingURL=ExifParser.js.map\n\n//# sourceURL=webpack://ian_webpack/./node_modules/ts-exif-parser/lib/ExifParser.js?");

/***/ }),

/***/ "./node_modules/ts-exif-parser/lib/ExifParserFactory.js":
/*!**************************************************************!*\
  !*** ./node_modules/ts-exif-parser/lib/ExifParserFactory.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ExifParserFactory = void 0;\r\nvar ExifParser_1 = __webpack_require__(/*! ./ExifParser */ \"./node_modules/ts-exif-parser/lib/ExifParser.js\");\r\nfunction getGlobal() {\r\n    return (1, eval)('this');\r\n}\r\nvar ExifParserFactory = /** @class */ (function () {\r\n    function ExifParserFactory() {\r\n    }\r\n    ExifParserFactory.create = function (buffer, global) {\r\n        global = global || getGlobal();\r\n        if (buffer instanceof global.ArrayBuffer) {\r\n            var DOMBufferStream = (__webpack_require__(/*! ./DOMBufferStream */ \"./node_modules/ts-exif-parser/lib/DOMBufferStream.js\").DOMBufferStream);\r\n            return new ExifParser_1.ExifParser(new DOMBufferStream(buffer, 0, buffer.byteLength, true, global));\r\n        }\r\n        else {\r\n            var NodeBufferStream = (__webpack_require__(/*! ./BufferStream */ \"./node_modules/ts-exif-parser/lib/BufferStream.js\").BufferStream);\r\n            return new ExifParser_1.ExifParser(new NodeBufferStream(buffer, 0, buffer.length, true));\r\n        }\r\n    };\r\n    return ExifParserFactory;\r\n}());\r\nexports.ExifParserFactory = ExifParserFactory;\r\n//# sourceMappingURL=ExifParserFactory.js.map\n\n//# sourceURL=webpack://ian_webpack/./node_modules/ts-exif-parser/lib/ExifParserFactory.js?");

/***/ }),

/***/ "./node_modules/ts-exif-parser/lib/ExifSectionParser.js":
/*!**************************************************************!*\
  !*** ./node_modules/ts-exif-parser/lib/ExifSectionParser.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, lets: true, white: true */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ExifSectionParser = exports.ExifSections = void 0;\r\nvar ExifSections;\r\n(function (ExifSections) {\r\n    ExifSections[ExifSections[\"IFD0\"] = 1] = \"IFD0\";\r\n    ExifSections[ExifSections[\"IFD1\"] = 2] = \"IFD1\";\r\n    ExifSections[ExifSections[\"GPSIFD\"] = 3] = \"GPSIFD\";\r\n    ExifSections[ExifSections[\"SubIFD\"] = 4] = \"SubIFD\";\r\n    ExifSections[ExifSections[\"InteropIFD\"] = 5] = \"InteropIFD\";\r\n})(ExifSections = exports.ExifSections || (exports.ExifSections = {}));\r\nvar ExifSectionParser = /** @class */ (function () {\r\n    function ExifSectionParser() {\r\n    }\r\n    ExifSectionParser.parseTags = function (stream, iterator) {\r\n        var tiffMarker;\r\n        try {\r\n            tiffMarker = ExifSectionParser.readHeader(stream);\r\n        }\r\n        catch (e) {\r\n            return false; //ignore APP1 sections with invalid headers\r\n        }\r\n        var subIfdOffset, gpsOffset, interopOffset;\r\n        var ifd0Stream = tiffMarker.openWithOffset(stream.nextUInt32()), IFD0 = ExifSections.IFD0;\r\n        ExifSectionParser.readIFDSection(tiffMarker, ifd0Stream, function (tagType, value, format) {\r\n            switch (tagType) {\r\n                case 0x8825:\r\n                    gpsOffset = value[0];\r\n                    break;\r\n                case 0x8769:\r\n                    subIfdOffset = value[0];\r\n                    break;\r\n                default:\r\n                    iterator(IFD0, tagType, value, format);\r\n                    break;\r\n            }\r\n        });\r\n        var ifd1Offset = ifd0Stream.nextUInt32();\r\n        if (ifd1Offset !== 0) {\r\n            var ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);\r\n            ExifSectionParser.readIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, ExifSections.IFD1));\r\n        }\r\n        if (gpsOffset) {\r\n            var gpsStream = tiffMarker.openWithOffset(gpsOffset);\r\n            ExifSectionParser.readIFDSection(tiffMarker, gpsStream, iterator.bind(null, ExifSections.GPSIFD));\r\n        }\r\n        if (subIfdOffset) {\r\n            var subIfdStream = tiffMarker.openWithOffset(subIfdOffset), InteropIFD_1 = ExifSections.InteropIFD;\r\n            ExifSectionParser.readIFDSection(tiffMarker, subIfdStream, function (tagType, value, format) {\r\n                if (tagType === 0xA005) {\r\n                    interopOffset = value[0];\r\n                }\r\n                else {\r\n                    iterator(InteropIFD_1, tagType, value, format);\r\n                }\r\n            });\r\n        }\r\n        if (interopOffset) {\r\n            var interopStream = tiffMarker.openWithOffset(interopOffset);\r\n            ExifSectionParser.readIFDSection(tiffMarker, interopStream, iterator.bind(null, ExifSections.InteropIFD));\r\n        }\r\n        return true;\r\n    };\r\n    ExifSectionParser.readExifValue = function (format, stream) {\r\n        switch (format) {\r\n            case 1:\r\n                return stream.nextUInt8();\r\n            case 3:\r\n                return stream.nextUInt16();\r\n            case 4:\r\n                return stream.nextUInt32();\r\n            case 5:\r\n                return [stream.nextUInt32(), stream.nextUInt32()];\r\n            case 6:\r\n                return stream.nextInt8();\r\n            case 8:\r\n                return stream.nextUInt16();\r\n            case 9:\r\n                return stream.nextUInt32();\r\n            case 10:\r\n                return [stream.nextInt32(), stream.nextInt32()];\r\n            case 11:\r\n                return stream.nextFloat();\r\n            case 12:\r\n                return stream.nextDouble();\r\n            default:\r\n                throw new Error('Invalid format while decoding: ' + format);\r\n        }\r\n    };\r\n    ExifSectionParser.getBytesPerComponent = function (format) {\r\n        switch (format) {\r\n            case 1:\r\n            case 2:\r\n            case 6:\r\n            case 7:\r\n                return 1;\r\n            case 3:\r\n            case 8:\r\n                return 2;\r\n            case 4:\r\n            case 9:\r\n            case 11:\r\n                return 4;\r\n            case 5:\r\n            case 10:\r\n            case 12:\r\n                return 8;\r\n            default:\r\n                return 0;\r\n        }\r\n    };\r\n    ExifSectionParser.readExifTag = function (tiffMarker, stream) {\r\n        var tagType = stream.nextUInt16(), format = stream.nextUInt16(), bytesPerComponent = ExifSectionParser.getBytesPerComponent(format), components = stream.nextUInt32(), valueBytes = bytesPerComponent * components, values, value, c;\r\n        /* if the value is bigger then 4 bytes, the value is in the data section of the IFD\r\n        and the value present in the tag is the offset starting from the tiff header. So we replace the stream\r\n        with a stream that is located at the given offset in the data section. s*/\r\n        if (valueBytes > 4) {\r\n            stream = tiffMarker.openWithOffset(stream.nextUInt32());\r\n        }\r\n        //we don't want to read strings as arrays\r\n        if (format === 2) {\r\n            values = stream.nextString(components);\r\n            //cut off \\0 characters\r\n            var lastNull = values.indexOf('\\0');\r\n            if (lastNull !== -1) {\r\n                values = values.substr(0, lastNull);\r\n            }\r\n        }\r\n        else if (format === 7) {\r\n            values = stream.nextBuffer(components);\r\n        }\r\n        else if (format !== 0) {\r\n            values = [];\r\n            for (c = 0; c < components; ++c) {\r\n                values.push(ExifSectionParser.readExifValue(format, stream));\r\n            }\r\n        }\r\n        //since our stream is a stateful object, we need to skip remaining bytes\r\n        //so our offset stays correct\r\n        if (valueBytes < 4) {\r\n            stream.skip(4 - valueBytes);\r\n        }\r\n        return [tagType, values, format];\r\n    };\r\n    ExifSectionParser.readIFDSection = function (tiffMarker, stream, iterator) {\r\n        // make sure we can read nextUint16 byte\r\n        if (stream.remainingLength() < 2) {\r\n            return;\r\n        }\r\n        var numberOfEntries = stream.nextUInt16(), tag, i;\r\n        for (i = 0; i < numberOfEntries; ++i) {\r\n            tag = ExifSectionParser.readExifTag(tiffMarker, stream);\r\n            iterator(tag[0], tag[1], tag[2]);\r\n        }\r\n    };\r\n    ExifSectionParser.readHeader = function (stream) {\r\n        var exifHeader = stream.nextString(6);\r\n        if (exifHeader !== 'Exif\\0\\0') {\r\n            throw new Error('Invalid EXIF header');\r\n        }\r\n        var tiffMarker = stream.mark();\r\n        var tiffHeader = stream.nextUInt16();\r\n        if (tiffHeader === 0x4949) {\r\n            stream.setBigEndian(false);\r\n        }\r\n        else if (tiffHeader === 0x4D4D) {\r\n            stream.setBigEndian(true);\r\n        }\r\n        else {\r\n            throw new Error('Invalid TIFF header');\r\n        }\r\n        if (stream.nextUInt16() !== 0x002A) {\r\n            throw new Error('Invalid TIFF data');\r\n        }\r\n        return tiffMarker;\r\n    };\r\n    return ExifSectionParser;\r\n}());\r\nexports.ExifSectionParser = ExifSectionParser;\r\n//# sourceMappingURL=ExifSectionParser.js.map\n\n//# sourceURL=webpack://ian_webpack/./node_modules/ts-exif-parser/lib/ExifSectionParser.js?");

/***/ }),

/***/ "./node_modules/ts-exif-parser/lib/JpegParser.js":
/*!*******************************************************!*\
  !*** ./node_modules/ts-exif-parser/lib/JpegParser.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.JpegParser = void 0;\r\nvar JpegParser = /** @class */ (function () {\r\n    function JpegParser() {\r\n    }\r\n    JpegParser.parseSections = function (stream, iterator) {\r\n        var len, markerType;\r\n        stream.setBigEndian(true);\r\n        //stop reading the stream at the SOS (Start of Stream) marker,\r\n        //because its length is not stored in the header so we can't\r\n        //know where to jump to. The only marker after that is just EOI (End Of Image) anyway\r\n        while (stream.remainingLength() > 0 && markerType !== 0xDA) {\r\n            if (stream.nextUInt8() !== 0xFF) {\r\n                return;\r\n            }\r\n            markerType = stream.nextUInt8();\r\n            //don't read size from markers that have no datas\r\n            if ((markerType >= 0xD0 && markerType <= 0xD9) || markerType === 0xDA) {\r\n                len = 0;\r\n            }\r\n            else {\r\n                len = stream.nextUInt16() - 2;\r\n            }\r\n            iterator(markerType, stream.branch(0, len));\r\n            stream.skip(len);\r\n        }\r\n    };\r\n    //stream should be located after SOF section size and in big endian mode, like passed to parseSections iterator\r\n    JpegParser.getSizeFromSOFSection = function (stream) {\r\n        stream.skip(1);\r\n        return {\r\n            height: stream.nextUInt16(),\r\n            width: stream.nextUInt16()\r\n        };\r\n    };\r\n    JpegParser.getSectionName = function (markerType) {\r\n        var name, index;\r\n        switch (markerType) {\r\n            case 0xD8:\r\n                name = 'SOI';\r\n                break;\r\n            case 0xC4:\r\n                name = 'DHT';\r\n                break;\r\n            case 0xDB:\r\n                name = 'DQT';\r\n                break;\r\n            case 0xDD:\r\n                name = 'DRI';\r\n                break;\r\n            case 0xDA:\r\n                name = 'SOS';\r\n                break;\r\n            case 0xFE:\r\n                name = 'COM';\r\n                break;\r\n            case 0xD9:\r\n                name = 'EOI';\r\n                break;\r\n            default:\r\n                if (markerType >= 0xE0 && markerType <= 0xEF) {\r\n                    name = 'APP';\r\n                    index = markerType - 0xE0;\r\n                }\r\n                else if (markerType >= 0xC0 && markerType <= 0xCF && markerType !== 0xC4 && markerType !== 0xC8 && markerType !== 0xCC) {\r\n                    name = 'SOF';\r\n                    index = markerType - 0xC0;\r\n                }\r\n                else if (markerType >= 0xD0 && markerType <= 0xD7) {\r\n                    name = 'RST';\r\n                    index = markerType - 0xD0;\r\n                }\r\n                break;\r\n        }\r\n        var nameStruct = {\r\n            name: name\r\n        };\r\n        if (typeof index === 'number') {\r\n            nameStruct.index = index;\r\n        }\r\n        return nameStruct;\r\n    };\r\n    return JpegParser;\r\n}());\r\nexports.JpegParser = JpegParser;\r\n//# sourceMappingURL=JpegParser.js.map\n\n//# sourceURL=webpack://ian_webpack/./node_modules/ts-exif-parser/lib/JpegParser.js?");

/***/ }),

/***/ "./node_modules/ts-exif-parser/lib/exif-tags.js":
/*!******************************************************!*\
  !*** ./node_modules/ts-exif-parser/lib/exif-tags.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Tags = void 0;\r\nvar Tags;\r\n(function (Tags) {\r\n    Tags.Exif = {\r\n        0x0001: \"InteropIndex\",\r\n        0x0002: \"InteropVersion\",\r\n        0x000B: \"ProcessingSoftware\",\r\n        0x00FE: \"SubfileType\",\r\n        0x00FF: \"OldSubfileType\",\r\n        0x0100: \"ImageWidth\",\r\n        0x0101: \"ImageHeight\",\r\n        0x0102: \"BitsPerSample\",\r\n        0x0103: \"Compression\",\r\n        0x0106: \"PhotometricInterpretation\",\r\n        0x0107: \"Thresholding\",\r\n        0x0108: \"CellWidth\",\r\n        0x0109: \"CellLength\",\r\n        0x010A: \"FillOrder\",\r\n        0x010D: \"DocumentName\",\r\n        0x010E: \"ImageDescription\",\r\n        0x010F: \"Make\",\r\n        0x0110: \"Model\",\r\n        0x0111: \"StripOffsets\",\r\n        0x0112: \"Orientation\",\r\n        0x0115: \"SamplesPerPixel\",\r\n        0x0116: \"RowsPerStrip\",\r\n        0x0117: \"StripByteCounts\",\r\n        0x0118: \"MinSampleValue\",\r\n        0x0119: \"MaxSampleValue\",\r\n        0x011A: \"XResolution\",\r\n        0x011B: \"YResolution\",\r\n        0x011C: \"PlanarConfiguration\",\r\n        0x011D: \"PageName\",\r\n        0x011E: \"XPosition\",\r\n        0x011F: \"YPosition\",\r\n        0x0120: \"FreeOffsets\",\r\n        0x0121: \"FreeByteCounts\",\r\n        0x0122: \"GrayResponseUnit\",\r\n        0x0123: \"GrayResponseCurve\",\r\n        0x0124: \"T4Options\",\r\n        0x0125: \"T6Options\",\r\n        0x0128: \"ResolutionUnit\",\r\n        0x0129: \"PageNumber\",\r\n        0x012C: \"ColorResponseUnit\",\r\n        0x012D: \"TransferFunction\",\r\n        0x0131: \"Software\",\r\n        0x0132: \"ModifyDate\",\r\n        0x013B: \"Artist\",\r\n        0x013C: \"HostComputer\",\r\n        0x013D: \"Predictor\",\r\n        0x013E: \"WhitePoint\",\r\n        0x013F: \"PrimaryChromaticities\",\r\n        0x0140: \"ColorMap\",\r\n        0x0141: \"HalftoneHints\",\r\n        0x0142: \"TileWidth\",\r\n        0x0143: \"TileLength\",\r\n        0x0144: \"TileOffsets\",\r\n        0x0145: \"TileByteCounts\",\r\n        0x0146: \"BadFaxLines\",\r\n        0x0147: \"CleanFaxData\",\r\n        0x0148: \"ConsecutiveBadFaxLines\",\r\n        0x014A: \"SubIFD\",\r\n        0x014C: \"InkSet\",\r\n        0x014D: \"InkNames\",\r\n        0x014E: \"NumberofInks\",\r\n        0x0150: \"DotRange\",\r\n        0x0151: \"TargetPrinter\",\r\n        0x0152: \"ExtraSamples\",\r\n        0x0153: \"SampleFormat\",\r\n        0x0154: \"SMinSampleValue\",\r\n        0x0155: \"SMaxSampleValue\",\r\n        0x0156: \"TransferRange\",\r\n        0x0157: \"ClipPath\",\r\n        0x0158: \"XClipPathUnits\",\r\n        0x0159: \"YClipPathUnits\",\r\n        0x015A: \"Indexed\",\r\n        0x015B: \"JPEGTables\",\r\n        0x015F: \"OPIProxy\",\r\n        0x0190: \"GlobalParametersIFD\",\r\n        0x0191: \"ProfileType\",\r\n        0x0192: \"FaxProfile\",\r\n        0x0193: \"CodingMethods\",\r\n        0x0194: \"VersionYear\",\r\n        0x0195: \"ModeNumber\",\r\n        0x01B1: \"Decode\",\r\n        0x01B2: \"DefaultImageColor\",\r\n        0x01B3: \"T82Options\",\r\n        0x01B5: \"JPEGTables\",\r\n        0x0200: \"JPEGProc\",\r\n        0x0201: \"ThumbnailOffset\",\r\n        0x0202: \"ThumbnailLength\",\r\n        0x0203: \"JPEGRestartInterval\",\r\n        0x0205: \"JPEGLosslessPredictors\",\r\n        0x0206: \"JPEGPointTransforms\",\r\n        0x0207: \"JPEGQTables\",\r\n        0x0208: \"JPEGDCTables\",\r\n        0x0209: \"JPEGACTables\",\r\n        0x0211: \"YCbCrCoefficients\",\r\n        0x0212: \"YCbCrSubSampling\",\r\n        0x0213: \"YCbCrPositioning\",\r\n        0x0214: \"ReferenceBlackWhite\",\r\n        0x022F: \"StripRowCounts\",\r\n        0x02BC: \"ApplicationNotes\",\r\n        0x03E7: \"USPTOMiscellaneous\",\r\n        0x1000: \"RelatedImageFileFormat\",\r\n        0x1001: \"RelatedImageWidth\",\r\n        0x1002: \"RelatedImageHeight\",\r\n        0x4746: \"Rating\",\r\n        0x4747: \"XP_DIP_XML\",\r\n        0x4748: \"StitchInfo\",\r\n        0x4749: \"RatingPercent\",\r\n        0x800D: \"ImageID\",\r\n        0x80A3: \"WangTag1\",\r\n        0x80A4: \"WangAnnotation\",\r\n        0x80A5: \"WangTag3\",\r\n        0x80A6: \"WangTag4\",\r\n        0x80E3: \"Matteing\",\r\n        0x80E4: \"DataType\",\r\n        0x80E5: \"ImageDepth\",\r\n        0x80E6: \"TileDepth\",\r\n        0x827D: \"Model2\",\r\n        0x828D: \"CFARepeatPatternDim\",\r\n        0x828E: \"CFAPattern2\",\r\n        0x828F: \"BatteryLevel\",\r\n        0x8290: \"KodakIFD\",\r\n        0x8298: \"Copyright\",\r\n        0x829A: \"ExposureTime\",\r\n        0x829D: \"FNumber\",\r\n        0x82A5: \"MDFileTag\",\r\n        0x82A6: \"MDScalePixel\",\r\n        0x82A7: \"MDColorTable\",\r\n        0x82A8: \"MDLabName\",\r\n        0x82A9: \"MDSampleInfo\",\r\n        0x82AA: \"MDPrepDate\",\r\n        0x82AB: \"MDPrepTime\",\r\n        0x82AC: \"MDFileUnits\",\r\n        0x830E: \"PixelScale\",\r\n        0x8335: \"AdventScale\",\r\n        0x8336: \"AdventRevision\",\r\n        0x835C: \"UIC1Tag\",\r\n        0x835D: \"UIC2Tag\",\r\n        0x835E: \"UIC3Tag\",\r\n        0x835F: \"UIC4Tag\",\r\n        0x83BB: \"IPTC-NAA\",\r\n        0x847E: \"IntergraphPacketData\",\r\n        0x847F: \"IntergraphFlagRegisters\",\r\n        0x8480: \"IntergraphMatrix\",\r\n        0x8481: \"INGRReserved\",\r\n        0x8482: \"ModelTiePoint\",\r\n        0x84E0: \"Site\",\r\n        0x84E1: \"ColorSequence\",\r\n        0x84E2: \"IT8Header\",\r\n        0x84E3: \"RasterPadding\",\r\n        0x84E4: \"BitsPerRunLength\",\r\n        0x84E5: \"BitsPerExtendedRunLength\",\r\n        0x84E6: \"ColorTable\",\r\n        0x84E7: \"ImageColorIndicator\",\r\n        0x84E8: \"BackgroundColorIndicator\",\r\n        0x84E9: \"ImageColorValue\",\r\n        0x84EA: \"BackgroundColorValue\",\r\n        0x84EB: \"PixelIntensityRange\",\r\n        0x84EC: \"TransparencyIndicator\",\r\n        0x84ED: \"ColorCharacterization\",\r\n        0x84EE: \"HCUsage\",\r\n        0x84EF: \"TrapIndicator\",\r\n        0x84F0: \"CMYKEquivalent\",\r\n        0x8546: \"SEMInfo\",\r\n        0x8568: \"AFCP_IPTC\",\r\n        0x85B8: \"PixelMagicJBIGOptions\",\r\n        0x85D8: \"ModelTransform\",\r\n        0x8602: \"WB_GRGBLevels\",\r\n        0x8606: \"LeafData\",\r\n        0x8649: \"PhotoshopSettings\",\r\n        0x8769: \"ExifOffset\",\r\n        0x8773: \"ICC_Profile\",\r\n        0x877F: \"TIFF_FXExtensions\",\r\n        0x8780: \"MultiProfiles\",\r\n        0x8781: \"SharedData\",\r\n        0x8782: \"T88Options\",\r\n        0x87AC: \"ImageLayer\",\r\n        0x87AF: \"GeoTiffDirectory\",\r\n        0x87B0: \"GeoTiffDoubleParams\",\r\n        0x87B1: \"GeoTiffAsciiParams\",\r\n        0x8822: \"ExposureProgram\",\r\n        0x8824: \"SpectralSensitivity\",\r\n        0x8825: \"GPSInfo\",\r\n        0x8827: \"ISO\",\r\n        0x8828: \"Opto-ElectricConvFactor\",\r\n        0x8829: \"Interlace\",\r\n        0x882A: \"TimeZoneOffset\",\r\n        0x882B: \"SelfTimerMode\",\r\n        0x8830: \"SensitivityType\",\r\n        0x8831: \"StandardOutputSensitivity\",\r\n        0x8832: \"RecommendedExposureIndex\",\r\n        0x8833: \"ISOSpeed\",\r\n        0x8834: \"ISOSpeedLatitudeyyy\",\r\n        0x8835: \"ISOSpeedLatitudezzz\",\r\n        0x885C: \"FaxRecvParams\",\r\n        0x885D: \"FaxSubAddress\",\r\n        0x885E: \"FaxRecvTime\",\r\n        0x888A: \"LeafSubIFD\",\r\n        0x9000: \"ExifVersion\",\r\n        0x9003: \"DateTimeOriginal\",\r\n        0x9004: \"CreateDate\",\r\n        0x9101: \"ComponentsConfiguration\",\r\n        0x9102: \"CompressedBitsPerPixel\",\r\n        0x9201: \"ShutterSpeedValue\",\r\n        0x9202: \"ApertureValue\",\r\n        0x9203: \"BrightnessValue\",\r\n        0x9204: \"ExposureCompensation\",\r\n        0x9205: \"MaxApertureValue\",\r\n        0x9206: \"SubjectDistance\",\r\n        0x9207: \"MeteringMode\",\r\n        0x9208: \"LightSource\",\r\n        0x9209: \"Flash\",\r\n        0x920A: \"FocalLength\",\r\n        0x920B: \"FlashEnergy\",\r\n        0x920C: \"SpatialFrequencyResponse\",\r\n        0x920D: \"Noise\",\r\n        0x920E: \"FocalPlaneXResolution\",\r\n        0x920F: \"FocalPlaneYResolution\",\r\n        0x9210: \"FocalPlaneResolutionUnit\",\r\n        0x9211: \"ImageNumber\",\r\n        0x9212: \"SecurityClassification\",\r\n        0x9213: \"ImageHistory\",\r\n        0x9214: \"SubjectArea\",\r\n        0x9215: \"ExposureIndex\",\r\n        0x9216: \"TIFF-EPStandardID\",\r\n        0x9217: \"SensingMethod\",\r\n        0x923A: \"CIP3DataFile\",\r\n        0x923B: \"CIP3Sheet\",\r\n        0x923C: \"CIP3Side\",\r\n        0x923F: \"StoNits\",\r\n        0x927C: \"MakerNote\",\r\n        0x9286: \"UserComment\",\r\n        0x9290: \"SubSecTime\",\r\n        0x9291: \"SubSecTimeOriginal\",\r\n        0x9292: \"SubSecTimeDigitized\",\r\n        0x932F: \"MSDocumentText\",\r\n        0x9330: \"MSPropertySetStorage\",\r\n        0x9331: \"MSDocumentTextPosition\",\r\n        0x935C: \"ImageSourceData\",\r\n        0x9C9B: \"XPTitle\",\r\n        0x9C9C: \"XPComment\",\r\n        0x9C9D: \"XPAuthor\",\r\n        0x9C9E: \"XPKeywords\",\r\n        0x9C9F: \"XPSubject\",\r\n        0xA000: \"FlashpixVersion\",\r\n        0xA001: \"ColorSpace\",\r\n        0xA002: \"ExifImageWidth\",\r\n        0xA003: \"ExifImageHeight\",\r\n        0xA004: \"RelatedSoundFile\",\r\n        0xA005: \"InteropOffset\",\r\n        0xA20B: \"FlashEnergy\",\r\n        0xA20C: \"SpatialFrequencyResponse\",\r\n        0xA20D: \"Noise\",\r\n        0xA20E: \"FocalPlaneXResolution\",\r\n        0xA20F: \"FocalPlaneYResolution\",\r\n        0xA210: \"FocalPlaneResolutionUnit\",\r\n        0xA211: \"ImageNumber\",\r\n        0xA212: \"SecurityClassification\",\r\n        0xA213: \"ImageHistory\",\r\n        0xA214: \"SubjectLocation\",\r\n        0xA215: \"ExposureIndex\",\r\n        0xA216: \"TIFF-EPStandardID\",\r\n        0xA217: \"SensingMethod\",\r\n        0xA300: \"FileSource\",\r\n        0xA301: \"SceneType\",\r\n        0xA302: \"CFAPattern\",\r\n        0xA401: \"CustomRendered\",\r\n        0xA402: \"ExposureMode\",\r\n        0xA403: \"WhiteBalance\",\r\n        0xA404: \"DigitalZoomRatio\",\r\n        0xA405: \"FocalLengthIn35mmFormat\",\r\n        0xA406: \"SceneCaptureType\",\r\n        0xA407: \"GainControl\",\r\n        0xA408: \"Contrast\",\r\n        0xA409: \"Saturation\",\r\n        0xA40A: \"Sharpness\",\r\n        0xA40B: \"DeviceSettingDescription\",\r\n        0xA40C: \"SubjectDistanceRange\",\r\n        0xA420: \"ImageUniqueID\",\r\n        0xA430: \"OwnerName\",\r\n        0xA431: \"SerialNumber\",\r\n        0xA432: \"LensInfo\",\r\n        0xA433: \"LensMake\",\r\n        0xA434: \"LensModel\",\r\n        0xA435: \"LensSerialNumber\",\r\n        0xA480: \"GDALMetadata\",\r\n        0xA481: \"GDALNoData\",\r\n        0xA500: \"Gamma\",\r\n        0xAFC0: \"ExpandSoftware\",\r\n        0xAFC1: \"ExpandLens\",\r\n        0xAFC2: \"ExpandFilm\",\r\n        0xAFC3: \"ExpandFilterLens\",\r\n        0xAFC4: \"ExpandScanner\",\r\n        0xAFC5: \"ExpandFlashLamp\",\r\n        0xBC01: \"PixelFormat\",\r\n        0xBC02: \"Transformation\",\r\n        0xBC03: \"Uncompressed\",\r\n        0xBC04: \"ImageType\",\r\n        0xBC80: \"ImageWidth\",\r\n        0xBC81: \"ImageHeight\",\r\n        0xBC82: \"WidthResolution\",\r\n        0xBC83: \"HeightResolution\",\r\n        0xBCC0: \"ImageOffset\",\r\n        0xBCC1: \"ImageByteCount\",\r\n        0xBCC2: \"AlphaOffset\",\r\n        0xBCC3: \"AlphaByteCount\",\r\n        0xBCC4: \"ImageDataDiscard\",\r\n        0xBCC5: \"AlphaDataDiscard\",\r\n        0xC427: \"OceScanjobDesc\",\r\n        0xC428: \"OceApplicationSelector\",\r\n        0xC429: \"OceIDNumber\",\r\n        0xC42A: \"OceImageLogic\",\r\n        0xC44F: \"Annotations\",\r\n        0xC4A5: \"PrintIM\",\r\n        0xC580: \"USPTOOriginalContentType\",\r\n        0xC612: \"DNGVersion\",\r\n        0xC613: \"DNGBackwardVersion\",\r\n        0xC614: \"UniqueCameraModel\",\r\n        0xC615: \"LocalizedCameraModel\",\r\n        0xC616: \"CFAPlaneColor\",\r\n        0xC617: \"CFALayout\",\r\n        0xC618: \"LinearizationTable\",\r\n        0xC619: \"BlackLevelRepeatDim\",\r\n        0xC61A: \"BlackLevel\",\r\n        0xC61B: \"BlackLevelDeltaH\",\r\n        0xC61C: \"BlackLevelDeltaV\",\r\n        0xC61D: \"WhiteLevel\",\r\n        0xC61E: \"DefaultScale\",\r\n        0xC61F: \"DefaultCropOrigin\",\r\n        0xC620: \"DefaultCropSize\",\r\n        0xC621: \"ColorMatrix1\",\r\n        0xC622: \"ColorMatrix2\",\r\n        0xC623: \"CameraCalibration1\",\r\n        0xC624: \"CameraCalibration2\",\r\n        0xC625: \"ReductionMatrix1\",\r\n        0xC626: \"ReductionMatrix2\",\r\n        0xC627: \"AnalogBalance\",\r\n        0xC628: \"AsShotNeutral\",\r\n        0xC629: \"AsShotWhiteXY\",\r\n        0xC62A: \"BaselineExposure\",\r\n        0xC62B: \"BaselineNoise\",\r\n        0xC62C: \"BaselineSharpness\",\r\n        0xC62D: \"BayerGreenSplit\",\r\n        0xC62E: \"LinearResponseLimit\",\r\n        0xC62F: \"CameraSerialNumber\",\r\n        0xC630: \"DNGLensInfo\",\r\n        0xC631: \"ChromaBlurRadius\",\r\n        0xC632: \"AntiAliasStrength\",\r\n        0xC633: \"ShadowScale\",\r\n        0xC634: \"DNGPrivateData\",\r\n        0xC635: \"MakerNoteSafety\",\r\n        0xC640: \"RawImageSegmentation\",\r\n        0xC65A: \"CalibrationIlluminant1\",\r\n        0xC65B: \"CalibrationIlluminant2\",\r\n        0xC65C: \"BestQualityScale\",\r\n        0xC65D: \"RawDataUniqueID\",\r\n        0xC660: \"AliasLayerMetadata\",\r\n        0xC68B: \"OriginalRawFileName\",\r\n        0xC68C: \"OriginalRawFileData\",\r\n        0xC68D: \"ActiveArea\",\r\n        0xC68E: \"MaskedAreas\",\r\n        0xC68F: \"AsShotICCProfile\",\r\n        0xC690: \"AsShotPreProfileMatrix\",\r\n        0xC691: \"CurrentICCProfile\",\r\n        0xC692: \"CurrentPreProfileMatrix\",\r\n        0xC6BF: \"ColorimetricReference\",\r\n        0xC6D2: \"PanasonicTitle\",\r\n        0xC6D3: \"PanasonicTitle2\",\r\n        0xC6F3: \"CameraCalibrationSig\",\r\n        0xC6F4: \"ProfileCalibrationSig\",\r\n        0xC6F5: \"ProfileIFD\",\r\n        0xC6F6: \"AsShotProfileName\",\r\n        0xC6F7: \"NoiseReductionApplied\",\r\n        0xC6F8: \"ProfileName\",\r\n        0xC6F9: \"ProfileHueSatMapDims\",\r\n        0xC6FA: \"ProfileHueSatMapData1\",\r\n        0xC6FB: \"ProfileHueSatMapData2\",\r\n        0xC6FC: \"ProfileToneCurve\",\r\n        0xC6FD: \"ProfileEmbedPolicy\",\r\n        0xC6FE: \"ProfileCopyright\",\r\n        0xC714: \"ForwardMatrix1\",\r\n        0xC715: \"ForwardMatrix2\",\r\n        0xC716: \"PreviewApplicationName\",\r\n        0xC717: \"PreviewApplicationVersion\",\r\n        0xC718: \"PreviewSettingsName\",\r\n        0xC719: \"PreviewSettingsDigest\",\r\n        0xC71A: \"PreviewColorSpace\",\r\n        0xC71B: \"PreviewDateTime\",\r\n        0xC71C: \"RawImageDigest\",\r\n        0xC71D: \"OriginalRawFileDigest\",\r\n        0xC71E: \"SubTileBlockSize\",\r\n        0xC71F: \"RowInterleaveFactor\",\r\n        0xC725: \"ProfileLookTableDims\",\r\n        0xC726: \"ProfileLookTableData\",\r\n        0xC740: \"OpcodeList1\",\r\n        0xC741: \"OpcodeList2\",\r\n        0xC74E: \"OpcodeList3\",\r\n        0xC761: \"NoiseProfile\",\r\n        0xC763: \"TimeCodes\",\r\n        0xC764: \"FrameRate\",\r\n        0xC772: \"TStop\",\r\n        0xC789: \"ReelName\",\r\n        0xC791: \"OriginalDefaultFinalSize\",\r\n        0xC792: \"OriginalBestQualitySize\",\r\n        0xC793: \"OriginalDefaultCropSize\",\r\n        0xC7A1: \"CameraLabel\",\r\n        0xC7A3: \"ProfileHueSatMapEncoding\",\r\n        0xC7A4: \"ProfileLookTableEncoding\",\r\n        0xC7A5: \"BaselineExposureOffset\",\r\n        0xC7A6: \"DefaultBlackRender\",\r\n        0xC7A7: \"NewRawImageDigest\",\r\n        0xC7A8: \"RawToPreviewGain\",\r\n        0xC7B5: \"DefaultUserCrop\",\r\n        0xEA1C: \"Padding\",\r\n        0xEA1D: \"OffsetSchema\",\r\n        0xFDE8: \"OwnerName\",\r\n        0xFDE9: \"SerialNumber\",\r\n        0xFDEA: \"Lens\",\r\n        0xFE00: \"KDC_IFD\",\r\n        0xFE4C: \"RawFile\",\r\n        0xFE4D: \"Converter\",\r\n        0xFE4E: \"WhiteBalance\",\r\n        0xFE51: \"Exposure\",\r\n        0xFE52: \"Shadows\",\r\n        0xFE53: \"Brightness\",\r\n        0xFE54: \"Contrast\",\r\n        0xFE55: \"Saturation\",\r\n        0xFE56: \"Sharpness\",\r\n        0xFE57: \"Smoothness\",\r\n        0xFE58: \"MoireFilter\"\r\n    };\r\n    Tags.GPS = {\r\n        0x0000: 'GPSVersionID',\r\n        0x0001: 'GPSLatitudeRef',\r\n        0x0002: 'GPSLatitude',\r\n        0x0003: 'GPSLongitudeRef',\r\n        0x0004: 'GPSLongitude',\r\n        0x0005: 'GPSAltitudeRef',\r\n        0x0006: 'GPSAltitude',\r\n        0x0007: 'GPSTimeStamp',\r\n        0x0008: 'GPSSatellites',\r\n        0x0009: 'GPSStatus',\r\n        0x000A: 'GPSMeasureMode',\r\n        0x000B: 'GPSDOP',\r\n        0x000C: 'GPSSpeedRef',\r\n        0x000D: 'GPSSpeed',\r\n        0x000E: 'GPSTrackRef',\r\n        0x000F: 'GPSTrack',\r\n        0x0010: 'GPSImgDirectionRef',\r\n        0x0011: 'GPSImgDirection',\r\n        0x0012: 'GPSMapDatum',\r\n        0x0013: 'GPSDestLatitudeRef',\r\n        0x0014: 'GPSDestLatitude',\r\n        0x0015: 'GPSDestLongitudeRef',\r\n        0x0016: 'GPSDestLongitude',\r\n        0x0017: 'GPSDestBearingRef',\r\n        0x0018: 'GPSDestBearing',\r\n        0x0019: 'GPSDestDistanceRef',\r\n        0x001A: 'GPSDestDistance',\r\n        0x001B: 'GPSProcessingMethod',\r\n        0x001C: 'GPSAreaInformation',\r\n        0x001D: 'GPSDateStamp',\r\n        0x001E: 'GPSDifferential',\r\n        0x001F: 'GPSHPositioningError'\r\n    };\r\n})(Tags = exports.Tags || (exports.Tags = {}));\r\n//# sourceMappingURL=exif-tags.js.map\n\n//# sourceURL=webpack://ian_webpack/./node_modules/ts-exif-parser/lib/exif-tags.js?");

/***/ }),

/***/ "./node_modules/ts-exif-parser/lib/simplify.js":
/*!*****************************************************!*\
  !*** ./node_modules/ts-exif-parser/lib/simplify.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.simplify = void 0;\r\nvar ExifSectionParser_1 = __webpack_require__(/*! ./ExifSectionParser */ \"./node_modules/ts-exif-parser/lib/ExifSectionParser.js\");\r\nvar DateUtil_1 = __webpack_require__(/*! ./DateUtil */ \"./node_modules/ts-exif-parser/lib/DateUtil.js\");\r\nvar simplify;\r\n(function (simplify) {\r\n    var degreeTags = [{\r\n            section: ExifSectionParser_1.ExifSections.GPSIFD,\r\n            type: 0x0002,\r\n            name: 'GPSLatitude',\r\n            refType: 0x0001,\r\n            refName: 'GPSLatitudeRef',\r\n            posVal: 'N'\r\n        },\r\n        {\r\n            section: ExifSectionParser_1.ExifSections.GPSIFD,\r\n            type: 0x0004,\r\n            name: 'GPSLongitude',\r\n            refType: 0x0003,\r\n            refName: 'GPSLongitudeRef',\r\n            posVal: 'E'\r\n        }];\r\n    var dateTags = [{\r\n            section: ExifSectionParser_1.ExifSections.SubIFD,\r\n            type: 0x0132,\r\n            name: 'ModifyDate'\r\n        },\r\n        {\r\n            section: ExifSectionParser_1.ExifSections.SubIFD,\r\n            type: 0x9003,\r\n            name: 'DateTimeOriginal'\r\n        },\r\n        {\r\n            section: ExifSectionParser_1.ExifSections.SubIFD,\r\n            type: 0x9004,\r\n            name: 'CreateDate'\r\n        },\r\n        {\r\n            section: ExifSectionParser_1.ExifSections.SubIFD,\r\n            type: 0x0132,\r\n            name: 'ModifyDate',\r\n        }];\r\n    function castDegreeValues(getTagValue, setTagValue) {\r\n        degreeTags.forEach(function (t) {\r\n            var degreeVal = getTagValue(t);\r\n            if (degreeVal) {\r\n                var degreeRef = getTagValue({ section: t.section, type: t.refType, name: t.refName });\r\n                var degreeNumRef = degreeRef === t.posVal ? 1 : -1;\r\n                var degree = (degreeVal[0] + (degreeVal[1] / 60) + (degreeVal[2] / 3600)) * degreeNumRef;\r\n                setTagValue(t, degree);\r\n            }\r\n        });\r\n    }\r\n    simplify.castDegreeValues = castDegreeValues;\r\n    function castDateValues(getTagValue, setTagValue) {\r\n        dateTags.forEach(function (t) {\r\n            var dateStrVal = getTagValue(t);\r\n            if (dateStrVal) {\r\n                //some easy checks to determine two common date formats\r\n                var timestamp = DateUtil_1.DateUtil.parseExifDate(dateStrVal);\r\n                if (typeof timestamp !== 'undefined') {\r\n                    setTagValue(t, timestamp);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    simplify.castDateValues = castDateValues;\r\n    function simplifyValue(values, format) {\r\n        if (Array.isArray(values)) {\r\n            values = values.map(function (value) {\r\n                if (format === 10 || format === 5) {\r\n                    return value[0] / value[1];\r\n                }\r\n                return value;\r\n            });\r\n            if (values.length === 1) {\r\n                values = values[0];\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n    simplify.simplifyValue = simplifyValue;\r\n})(simplify = exports.simplify || (exports.simplify = {}));\r\n//# sourceMappingURL=simplify.js.map\n\n//# sourceURL=webpack://ian_webpack/./node_modules/ts-exif-parser/lib/simplify.js?");

/***/ }),

/***/ "./static/ts/index.ts":
/*!****************************!*\
  !*** ./static/ts/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ts_exif_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ts-exif-parser */ \"./node_modules/ts-exif-parser/index.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nfunction handleFileSelect(evt) {\n    return __awaiter(this, void 0, void 0, function () {\n        var files, _i, files_1, file, buffer, parser, output;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    files = evt.target.files;\n                    _i = 0, files_1 = files;\n                    _a.label = 1;\n                case 1:\n                    if (!(_i < files_1.length)) return [3 /*break*/, 4];\n                    file = files_1[_i];\n                    return [4 /*yield*/, file.arrayBuffer()];\n                case 2:\n                    buffer = _a.sent();\n                    parser = ts_exif_parser__WEBPACK_IMPORTED_MODULE_0__.ExifParserFactory.create(buffer);\n                    output = parser.parse();\n                    console.log(output.tags);\n                    _a.label = 3;\n                case 3:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\ndocument.onreadystatechange = function () {\n    document.getElementById('files').addEventListener('change', handleFileSelect, false);\n};\n\n\n//# sourceURL=webpack://ian_webpack/./static/ts/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./static/ts/index.ts");
/******/ 	
/******/ })()
;